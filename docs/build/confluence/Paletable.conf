<p>The Paletable module contains the Paletable class and its attributes. Said attributes can be combined with top level objects, such as enrollment, to filter data by a variety of meterics. These metrics include age range, ethnicity, file data, income bracket, gender and state. Paletable also contains fetch(), the attribute used to return datafranes created by high level objects.</p>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable</ac:parameter>
</ac:structured-macro>
<em>class </em><code>Paletable.</code><strong><code>Paletable</code></strong>(<em><em>runIds</em>: <em>Optional[list]</em> = None</em>)</dt>
<dd><p>Bases: <code>object</code></p>
<p>Class containing attributes that can be combined with other classes from the PALET library. These attributes allow users to filter and return the dataframes created by high level objects.</p>
<ac:structured-macro ac:name="info">
<ac:rich-text-body>
<p>The Paletable class is inherited from high level objects such as enrollment, as such it does not need to be imported seperately. Once imported, the Article class is not called. Rather its attributes are called after a high level object.</p>
</ac:rich-text-body>
</ac:structured-macro>
<p style="font-weight: bold; margin-top: 30px">Example</p>
<p>Import enrollment:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> from palet.Enrollment import Enrollment]]></ac:plain-text-body>
</ac:structured-macro>
<p>Create dataframe:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> e = Enrollment().byState()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return dataframe:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> e.fetch()]]></ac:plain-text-body>
</ac:structured-macro>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.setLoggingLevel</ac:parameter>
</ac:structured-macro>
<strong><code>setLoggingLevel</code></strong>(<em><em>level</em>: <em>str</em></em>)</dt>
<dd></dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byAgeRange</ac:parameter>
</ac:structured-macro>
<strong><code>byAgeRange</code></strong>(<em><em>age_range</em>=None</em>)</dt>
<dd><p>Filter your query by Age Range. Most top level objects inherit this function such as Enrollment, Trend, etc. If your object is already set by a by group this will add it as the next by group.</p>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><ul>
<li>
<p><strong>age_range</strong> – <em>dict, optional</em>: Filter a single age, range such as {‘Minor’: [0,17]} or two or more age ranges such as {‘Minor’: [0,17],’Young Adult’: [18,25]}</p>
</li>
<li>
<p><strong>default</strong> – <em>none</em>: Defaults to pre-existing age ranges in <code>age_grp_code()</code></p>
</li>
</ul>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><a href="#top"><code>Paletable</code></a>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
<ac:structured-macro ac:name="info">
<ac:rich-text-body>
<p>The lowest possible age within TAF data is 0 while the highest is 125.</p>
</ac:rich-text-body>
</ac:structured-macro>
<p style="font-weight: bold; margin-top: 30px">Example</p>
<p>Start with an enrollment object:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Enrollment()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Default Option, returns DataFrame filtered by the age ranges defined in age_grp_cd:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> df = api.byAgeRange()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(df.fetch())]]></ac:plain-text-body>
</ac:structured-macro>
<p>User defined option, analyst enters a dictionary of labels with minimum and maximum ages:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> df = api.byAgeRange({'Teenager': [13,19],'Twenties': [20,29],'Thirties': [30,39]})]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(df.fetch())]]></ac:plain-text-body>
</ac:structured-macro>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.usingRunIds</ac:parameter>
</ac:structured-macro>
<strong><code>usingRunIds</code></strong>(<em><em>ids</em>: <em>Optional[list]</em> = None</em>)</dt>
<dd><p>For users who which to pass in their own Run Ids, call this method by passing in a list of run ids separated by comma. e.g. [6279, 6280]</p>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><ul>
<li>
<p><strong>ids</strong> – <em>list, optional</em>: Filter by specific runids by passing in a list of one or more.</p>
</li>
<li>
<p><strong>default</strong> – <em>none</em>: Defaults to an Empty List [] and will clear user defined run ids when called by default</p>
</li>
</ul>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p>No return values</p>
</td>
</tr>
</tbody>
</table>
<p style="font-weight: bold; margin-top: 30px">Example</p>
<p>Start with a Paletable object:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Enrollment()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Specify run ids:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api.usingRunIds([6279, 6280])]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(api.fetch())]]></ac:plain-text-body>
</ac:structured-macro>
<p>Alternatively enter the list of run ids as a parameter of the Paletable object:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Enrollment([6279, 6280])]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(api.fetch())]]></ac:plain-text-body>
</ac:structured-macro>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.displayCurrentRunIds</ac:parameter>
</ac:structured-macro>
<strong><code>displayCurrentRunIds</code></strong>()</dt>
<dd><p>If you’d like to get a display of the current run ids set in the query then you can call this function or check the full sql statement by <ac:link ac:anchor="Paletable.Paletable.sql">
<ac:link-body><code>sql()</code></ac:link-body>
</ac:link>.</p>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><p><strong>None</strong> – </p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p>Prints the current list of run ids to the screen.</p>
</td>
</tr>
</tbody>
</table>
<p style="font-weight: bold; margin-top: 30px">Example</p>
<p>Create a Paletable object:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Eligibility()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return a list of the default run ids:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api.displayCurrentRunIds()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Manually specify a list of run ids:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api.usingRunIds([6279, 6280])]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return a list of the user defined run ids:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api.displayCurrentRunIds()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Alternatively print the backend sql query and check the run ids there:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> print(api.sql())]]></ac:plain-text-body>
</ac:structured-macro>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byRaceEthnicity</ac:parameter>
</ac:structured-macro>
<strong><code>byRaceEthnicity</code></strong>(<em><em>ethnicity</em>=None</em>)</dt>
<dd><p>Filter your query by Race. Most top level objects inherit this function such as Enrollment, Trend, etc. If your object is already set by a by group this will add it as the next by group. The values in race column correspond to the to the codes and races from race_ethncty_flag in TAF. See race_ethncty_flag in <code>PaletMetadata</code>.</p>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><ul>
<li>
<p><strong>ethnicity</strong> – <em>str, optional</em>: Filter a single race by entering the corresponding code from race_ethncty_flag</p>
</li>
<li>
<p><strong>default</strong> – <em>none</em>: Filter by all races in race_ethncty_flag</p>
</li>
</ul>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
<ac:structured-macro ac:name="info">
<ac:rich-text-body>
<p>The codes and corresponding races of race_ethncty_flag can be found in <code>PaletMetadata</code>.</p>
</ac:rich-text-body>
</ac:structured-macro>
<p style="font-weight: bold; margin-top: 30px">Example</p>
<p>Start with a Paletable object and use the default option to filter query by race and ethnicity:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Enrollment().byRaceEthnicity()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(api.fetch())]]></ac:plain-text-body>
</ac:structured-macro>
<p>Focus in on one race, in this example Asian beneficiaries:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Enrollment().byRaceEthnicity('3')]]></ac:plain-text-body>
</ac:structured-macro>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byRaceEthnicityExpanded</ac:parameter>
</ac:structured-macro>
<strong><code>byRaceEthnicityExpanded</code></strong>(<em><em>ethnicity</em>=None</em>)</dt>
<dd><p>Filter your query by Race Ethnicity Expanded. Most top level objects inherit this function such as Enrollment, Trend, etc. If your object is already set by a by group this will add it as the next by group. The values in the raceExpanded column correspond to the to the codes and races from race_ethncty_exp_flag in TAF. See race_ethncty_exp_flag in PaletMetadata.</p>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><ul>
<li>
<p><strong>ethnicity</strong> – <em>str, optional</em>: Filter a single race by entering the corresponding code from race_ethncty_exp_flag</p>
</li>
<li>
<p><strong>default</strong> – <em>none</em>: Filter by all races in race_ethncty_exp_flag</p>
</li>
</ul>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
<ac:structured-macro ac:name="info">
<ac:rich-text-body>
<p>The codes and corresponding races of race_ethncty_exp_flag can be found in PaletMetadata.</p>
</ac:rich-text-body>
</ac:structured-macro>
<p style="font-weight: bold; margin-top: 30px">Example</p>
<p>Start with a Paletable object and use the default option to filter query by race and ethnicity:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Enrollment().byRaceEthnicityExpanded()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(api.fetch())]]></ac:plain-text-body>
</ac:structured-macro>
<p>Focus in on one race, in this example Native American beneficiaries:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Enrollment().byRaceEthnicityExpanded('3')]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(api.fetch())]]></ac:plain-text-body>
</ac:structured-macro>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byEthnicity</ac:parameter>
</ac:structured-macro>
<strong><code>byEthnicity</code></strong>(<em><em>ethnicity</em>=None</em>)</dt>
<dd><p>Filter your query by Ethnicity. Most top level objects inherit this function such as Enrollment, Trend, etc. If your object is already set by a by group this will add it as the next by group. The values in the ethnicity column correspond to the to the codes and races from ethncty_cd in TAF. See ethncty_cd in PaletMetadata.</p>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><ul>
<li>
<p><strong>ethnicity</strong> – <em>str, optional</em>: Filter a single ethnicity by entering the corresponding code from ethncty_cd</p>
</li>
<li>
<p><strong>default</strong> – <em>none</em>: Filter by all ethnicities in ethncty_cd</p>
</li>
</ul>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
<ac:structured-macro ac:name="info">
<ac:rich-text-body>
<p>The codes and corresponding races of race_ethncty_flag can be found in PaletMetadata.</p>
</ac:rich-text-body>
</ac:structured-macro>
<p style="font-weight: bold; margin-top: 30px">Example</p>
<p>Start with a Paletable object and use the default option to filter query by ethnicity:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Enrollment().byEthnicity()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(api.fetch())]]></ac:plain-text-body>
</ac:structured-macro>
<p>Focus in on one race, in this example Cuban beneficiaries:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Enrollment().byEthnicity('3')]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(api.fetch())]]></ac:plain-text-body>
</ac:structured-macro>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byGender</ac:parameter>
</ac:structured-macro>
<strong><code>byGender</code></strong>(<em><em>gender</em>=None</em>)</dt>
<dd><p>Filter your query by Gender. Most top level objects inherit this function such as Enrollment, Trend, etc. If your object is already set by a by group this will add it as the next by group. This by group is filtering using the gndr_cd column in the TAF data.</p>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><ul>
<li>
<p><strong>gender</strong> – <em>str, optional</em>: Filter by a single gender using the corresponding code from gndr_cd</p>
</li>
<li>
<p><strong>default</strong> – <em>none</em>: Defaults to filtering by all three options: -1 (null), F (female), M (male).</p>
</li>
</ul>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
<p style="font-weight: bold; margin-top: 30px">Example</p>
<p>Create a Paletable object:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Eligibility()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Use byGender() to filter the DataFrame by gender:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> df = api.byGender().fetch()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return the DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(df)]]></ac:plain-text-body>
</ac:structured-macro>
<p>Pivot to focus only on male beneficiaries:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> df = api.byGender('M').fetch()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return the DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(df)]]></ac:plain-text-body>
</ac:structured-macro>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byState</ac:parameter>
</ac:structured-macro>
<strong><code>byState</code></strong>(<em><em>state_cd</em>=None</em>)</dt>
<dd><dl>
<dt>Filter your query by State with total enrollment. Most top level objects inherit this function such as Enrollment, Trend, etc.</dt>
<dd>
<p>If your object is already set by a by group this will add it as the next by group.</p>
</dd>
</dl>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><ul>
<li>
<p><strong>state_fips</strong> – <em>str, (optional)</em>: Filter by a single State using FIPS code.</p>
</li>
<li>
<p><strong>default</strong> – <em>none</em>: Filter the Paletable object by all states and territories.</p>
</li>
</ul>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
<p style="font-weight: bold; margin-top: 30px">Example</p>
<p>Create a Paletable object for enrollment filtered by state:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Enrollment().byState()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return the object as DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(api.fetch())]]></ac:plain-text-body>
</ac:structured-macro>
<p>Focus in one state, for this example Alabama:</p>
<p>api = Enrollment().byState(‘01’)</p>
<p>Return the object as DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(api.fetch())]]></ac:plain-text-body>
</ac:structured-macro>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byCoverageTypeObject</ac:parameter>
</ac:structured-macro>
<strong><code>byCoverageTypeObject</code></strong>(<em><em>type</em>=None</em>)</dt>
<dd><p>DEPRECATED Filter your query by coverage type. Most top level objects inherit this function such as Enrollment, Trend, etc. If your object is already set by a by group this will add it as the next by group.</p>
<ac:structured-macro ac:name="info">
<ac:rich-text-body>
<p>This function inherits from the deprecated <ac:link ac:anchor="Coverage(Deprecated)">
<ri:page ri:content-title="Coverage (Deprecated)" />
<ac:link-body><code>Coverage</code></ac:link-body>
</ac:link> class and is no longer supported. Please see <ac:link ac:anchor="Paletable.Paletable.byCoverageType">
<ac:link-body><code>byCoverageType()</code></ac:link-body>
</ac:link>.</p>
</ac:rich-text-body>
</ac:structured-macro>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><p><strong>type</strong> – <em>str, (optional)</em>: Filter by coverage type using coverage code. Defaults to None.</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byCoverageType</ac:parameter>
</ac:structured-macro>
<strong><code>byCoverageType</code></strong>(<em><em>type</em>=None</em>)</dt>
<dd><dl>
<dt>Filter your query by coverage type. Most top level objects inherit this function such as Enrollment, Trend, etc.</dt>
<dd>
<p>If your object is already set by a by group this will add it as the next by group. Coverage type codes and values correspond to coverage_type in PaletMetadata.</p>
</dd>
</dl>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><ul>
<li>
<p><strong>type</strong> – <em>str, (optional)</em>: Filter by an individual coverage type using coverage code.</p>
</li>
<li>
<p><strong>default</strong> – <em>none</em>: Filter by all available coverage types.</p>
</li>
</ul>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
<ac:structured-macro ac:name="info">
<ac:rich-text-body>
<p>The <ac:link ac:anchor="CoverageType">
<ri:page ri:content-title="CoverageType" />
<ac:link-body><code>CoverageType</code></ac:link-body>
</ac:link> class is automatically imported when this by group is called.</p>
</ac:rich-text-body>
</ac:structured-macro>
<p style="font-weight: bold; margin-top: 30px">Example</p>
<p>Create Paletable object:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Enrollment().byCoverageType()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return Paletable object as a DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(api.fetch())]]></ac:plain-text-body>
</ac:structured-macro>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byEnrollmentType</ac:parameter>
</ac:structured-macro>
<strong><code>byEnrollmentType</code></strong>()</dt>
<dd><p>Filter your query by enrollment type. Most top level objects inherit this function such as Eligibility, Trend, etc. If your object is already set by a by group this will add it as the next by group. Enrollment type codes and values correspond to chip_cd in PaletMetadata.</p>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><ul>
<li>
<p><strong>type</strong> – <em>str, (optional)</em>: Filter by an individual enrollment type using enrollment type code.</p>
</li>
<li>
<p><strong>default</strong> – <em>none</em>: Filter by all available enrollment types</p>
</li>
</ul>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
<p style="font-weight: bold; margin-top: 30px">Example</p>
<p>Create Paletable object:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Enrollment().byEnrollmentType()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return Paletable object as a DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(api.fetch())]]></ac:plain-text-body>
</ac:structured-macro>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byMedicaidOnly</ac:parameter>
</ac:structured-macro>
<strong><code>byMedicaidOnly</code></strong>(<em><em>state_fips</em>=None</em>)</dt>
<dd><p>Filter your query to only include counts and percentage changes for Medicaid. Most top level objects inherit this function such as Enrollment, Trend, etc. If your object is already set by a by group this will add it as the next by group.</p>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><ul>
<li>
<p><strong>state_fips</strong> – <em>str, (optional)</em>: Filter by State using FIPS code.</p>
</li>
<li>
<p><strong>default</strong> – <em>none</em>: Change counts to focus only on Medicaid.</p>
</li>
</ul>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
<p style="font-weight: bold; margin-top: 30px">Example</p>
<p>Create Paletable object:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Enrollment().byMedicaidOnly()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return Paletable object as a DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(api.fetch())]]></ac:plain-text-body>
</ac:structured-macro>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byIncomeBracket</ac:parameter>
</ac:structured-macro>
<strong><code>byIncomeBracket</code></strong>(<em><em>bracket</em>=None</em>)</dt>
<dd><dl>
<dt>Filter your query by income bracket. Most top level objects inherit this function such as Enrollment, Trend, etc.</dt>
<dd>
<p>If your object is already set by a by group this will add it as the next by group.</p>
</dd>
</dl>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><ul>
<li>
<p><strong>bracket</strong> (<em>str, (optional)</em>: Filter by incm_cd, can be individual, range, or multiple. See examples below.) – </p>
</li>
<li>
<p><strong>default</strong> (<em>none</em>: Filter data by all possible incm_cd’s.) – </p>
</li>
</ul>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><strong>Spark DataFrame</strong></p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
</tbody>
</table>
<p style="font-weight: bold; margin-top: 30px">Examples</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> Enrollment.byIncomeBracket('01')
or
>>> Trend.byIncomeBracket('01-03')
or
>>> Trend.byIncomeBracket('02,03,05')]]></ac:plain-text-body>
</ac:structured-macro>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byYear</ac:parameter>
</ac:structured-macro>
<strong><code>byYear</code></strong>(<em><em>year</em>: <em>Optional[int]</em> = None</em>, <em><em>count</em>: <em>int</em> = 1</em>)</dt>
<dd><p>Filter your query by Year. Most top level objects inherit this function such as Enrollment, Trend, etc.</p>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><ul>
<li>
<p><strong>year</strong> – <em>int, (optional)</em>: Filter by year using the year in numerical format. Defaults to None.</p>
</li>
<li>
<p><strong>count</strong> – <em>int, (optional)</em>: Specify the number of years before or after the year specified. Defaults to 1.</p>
</li>
<li>
<p><strong>default</strong> – <em>none</em>: Filter object by all states and territories available.</p>
</li>
</ul>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
<p style="font-weight: bold; margin-top: 30px">Example</p>
<p>Create Paletable object filtering by all available years:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Enrollment().byYear()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return object as a DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(api.fetch())]]></ac:plain-text-body>
</ac:structured-macro>
<p>Create Paletable object filtering by 2019 and 2020:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Enrollment().byYear(2019, 1)]]></ac:plain-text-body>
</ac:structured-macro>
<p>Or alternatively:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = api = Enrollment().byYear(2020, -1)]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return object as a DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(api.fetch())]]></ac:plain-text-body>
</ac:structured-macro>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byMonth</ac:parameter>
</ac:structured-macro>
<strong><code>byMonth</code></strong>(<em><em>month</em>: <em>Optional[int]</em> = None</em>)</dt>
<dd><p>Filter your query by Month. Most top level objects inherit this function such as Enrollment, Trend, etc.</p>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><ul>
<li>
<p><strong>month</strong> – <em>int, (optional)</em>: Filter by a specific month using the month in numerical format.</p>
</li>
<li>
<p><strong>default</strong> – <em>none</em>: Filter object by all available months.</p>
</li>
</ul>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
<p style="font-weight: bold; margin-top: 30px">Example</p>
<p>Create Paletable object filtering by all available months:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Enrollment().byMonth()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return object as a DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(api.fetch())]]></ac:plain-text-body>
</ac:structured-macro>
<p>Create Paletable object focusing only on the month of December in the given time period:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Enrollment().byMonth(12)]]></ac:plain-text-body>
</ac:structured-macro>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.sql</ac:parameter>
</ac:structured-macro>
<strong><code>sql</code></strong>()</dt>
<dd><p>The SQL query that the Enrollment class uses to pull dataframes.</p>
<p>This can be called allowing an analyst to view the SQL the Enrollment is using.</p>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><p><strong>None</strong> – No input required.</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p>Returns a text string containing the SQL query run by the Enrollment class.</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>str</p>
</td>
</tr>
</tbody>
</table>
<p style="font-weight: bold; margin-top: 30px">Example</p>
<p>Create object containing the SQL query:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> q = Enrollment().byState().sql()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return the query as text:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> print(q)]]></ac:plain-text-body>
</ac:structured-macro>
<p>Alternatively</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> print(Enrollment().byState().sql())]]></ac:plain-text-body>
</ac:structured-macro>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.fetch</ac:parameter>
</ac:structured-macro>
<strong><code>fetch</code></strong>()</dt>
<dd><p>Call this method at the end of an object when you are ready for results.</p>
<p>This can be leveraged with display() to quickly pivot results.</p>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><p><strong>None</strong> – No input required</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p>Executes your query and returns a Spark Datarame.</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark Datarame</p>
</td>
</tr>
</tbody>
</table>
<p style="font-weight: bold; margin-top: 30px">Example</p>
<p>Create object for enrollment by state and year</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Enrollment().byState()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return Spark DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api.fetch]]></ac:plain-text-body>
</ac:structured-macro>
<p>Lever display() to pivot from yearly to monthly</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(api.byMonth().fetch())]]></ac:plain-text-body>
</ac:structured-macro>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.log</ac:parameter>
</ac:structured-macro>
<strong><code>log</code></strong>(<em><em>viewname</em>: <em>str</em></em>, <em><em>sql</em>=&apos;&apos;</em>)</dt>
<dd><p>This attribute allows you to print out the sql of a specific view within databricks or a database</p>
</dd>
</dl>
</dd>
</dl>
