<p>The Paletable module contains the Paletable class and its attributes. Said attributes can be combined with top level objects, such as enrollment, to filter data by a variety of meterics. These metrics include age range, ethnicity, file data, income bracket, gender and state. Paletable also contains fetch(), the attribute used to return datafranes created by high level objects.</p>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable</ac:parameter>
</ac:structured-macro>
<em>class </em><code>Paletable.</code><strong><code>Paletable</code></strong>(<em><em>runIds</em>: <em>Optional[list]</em> = None</em>)</dt>
<dd><p>Bases: <code>object</code></p>
<p>Class containing attributes that can be combined with other classes from the PALET library. These attributes allow users to filter and return the dataframes created by high level objects.</p>
<ac:structured-macro ac:name="info">
<ac:rich-text-body>
<p>The Paletable class is inherited from high level objects such as enrollment, as such it does not need to be imported seperately. Once imported, the Article class is not called. Rather its attributes are called after a high level object.</p>
</ac:rich-text-body>
</ac:structured-macro>
<p style="font-weight: bold; margin-top: 30px">Example</p>
<p>Import enrollment:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> from palet.Enrollment import Enrollment]]></ac:plain-text-body>
</ac:structured-macro>
<p>Create dataframe:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> e = Enrollment().byState()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return dataframe:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> e.fetch()]]></ac:plain-text-body>
</ac:structured-macro>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.setLoggingLevel</ac:parameter>
</ac:structured-macro>
<strong><code>setLoggingLevel</code></strong>(<em><em>level</em>: <em>str</em></em>)</dt>
<dd></dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byAgeRange</ac:parameter>
</ac:structured-macro>
<strong><code>byAgeRange</code></strong>(<em><em>age_range</em>=None</em>)</dt>
<dd><dl>
<dt>Filter your query by Age Range. Most top level objects inherit this</dt>
<dd>
<p>function such as Enrollment, Trend, etc. If your object is already set by a by group this will add it as the next by group.</p>
</dd>
</dl>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><ul>
<li>
<p><strong>age_range</strong> – <em>dict, optional</em>: Filter a single age, range such as {‘Minor’: [0,17]}</p>
</li>
<li>
<p><strong>{&apos;Minor&apos;</strong> (<em>Or two</em><em> or </em><em>more age ranges such as</em>) – [0,17],’Young Adult’: [18,25]}</p>
</li>
<li>
<p><strong>age_grp_code</strong> (<em>Defaults to pre-existing age ranges in</em>) – </p>
</li>
</ul>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><a href="#top"><code>Paletable</code></a>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.usingRunIds</ac:parameter>
</ac:structured-macro>
<strong><code>usingRunIds</code></strong>(<em><em>ids</em>: <em>Optional[list]</em> = None</em>)</dt>
<dd><p>For users who which to pass in their own Run Ids, call this method by passing in a list of run ids separated by comma. e.g. [6279, 6280]</p>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><ul>
<li>
<p><strong>ids</strong> – <em>list, optional</em>: Filter by specific runids by passing in a list of one or more.</p>
</li>
<li>
<p><strong>default</strong> (<em>Defaults to an Empty List</em><em> [</em><em>] </em><em>and will clear user defined run ids when called by</em>) – </p>
</li>
</ul>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p>No return values</p>
</td>
</tr>
</tbody>
</table>
<p style="font-weight: bold; margin-top: 30px">Example</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api.usingRunIds([6279, 6280])]]></ac:plain-text-body>
</ac:structured-macro>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.displayCurrentRunIds</ac:parameter>
</ac:structured-macro>
<strong><code>displayCurrentRunIds</code></strong>()</dt>
<dd><dl>
<dt>If you’d like to get a display of the current run ids set in the query then you can call this function</dt>
<dd>
<p>or check the full sql statement by :func:sql()</p>
</dd>
</dl>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><p><strong>None</strong> – </p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p>Prints the current list of run ids to the screen.</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byRaceEthnicity</ac:parameter>
</ac:structured-macro>
<strong><code>byRaceEthnicity</code></strong>(<em><em>ethnicity</em>=None</em>)</dt>
<dd><dl>
<dt>Filter your query by Race. Most top level objects inherit this function such as Enrollment, Trend, etc.</dt>
<dd>
<p>If your object is already set by a by group this will add it as the next by group.</p>
</dd>
</dl>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><p><strong>ethnicity</strong> – <em>str, optional</em>: Filter a single ethnicity. Defaults to None.</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byRaceEthnicityExpanded</ac:parameter>
</ac:structured-macro>
<strong><code>byRaceEthnicityExpanded</code></strong>(<em><em>ethnicity</em>=None</em>)</dt>
<dd><dl>
<dt>Filter your query by Expanded Race. Most top level objects inherit this function such as Enrollment, Trend, etc.</dt>
<dd>
<p>If your object is already set by a by group this will add it as the next by group.</p>
</dd>
</dl>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><p><strong>ethnicity</strong> – <em>str, optional</em>: Filter a single expanded ethnicity group. Defaults to None.</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byEthnicity</ac:parameter>
</ac:structured-macro>
<strong><code>byEthnicity</code></strong>(<em><em>ethnicity</em>=None</em>)</dt>
<dd><dl>
<dt>Filter your query by Ethnicity. Most top level objects inherit this function such as Enrollment, Trend, etc.</dt>
<dd>
<p>If your object is already set by a by group this will add it as the next by group.</p>
</dd>
</dl>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><p><strong>ethnicity</strong> – <em>str, optional</em>: Filter a single expanded ethnicity group. Defaults to None.</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byGender</ac:parameter>
</ac:structured-macro>
<strong><code>byGender</code></strong>(<em><em>gender</em>=None</em>)</dt>
<dd><dl>
<dt>Filter your query by Gender. Most top level objects inherit this function such as Enrollment, Trend, etc.</dt>
<dd>
<p>If your object is already set by a by group this will add it as the next by group.</p>
</dd>
</dl>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><p><strong>gender</strong> – <em>str, optional</em>: Filter by gender. Defaults to None.</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byState</ac:parameter>
</ac:structured-macro>
<strong><code>byState</code></strong>(<em><em>state_cd</em>=None</em>)</dt>
<dd><dl>
<dt>Filter your query by State with total enrollment. Most top level objects inherit this function such as Enrollment, Trend, etc.</dt>
<dd>
<p>If your object is already set by a by group this will add it as the next by group.</p>
</dd>
</dl>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><p><strong>state_fips</strong> – <em>str, (optional)</em>: Filter by State using FIPS code. See also <code>State.__init__()</code>. Defaults to None.</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byCoverageTypeObject</ac:parameter>
</ac:structured-macro>
<strong><code>byCoverageTypeObject</code></strong>(<em><em>type</em>=None</em>)</dt>
<dd><dl>
<dt>Filter your query by coverage type. Most top level objects inherit this function such as Enrollment, Trend, etc.</dt>
<dd>
<p>If your object is already set by a by group this will add it as the next by group.</p>
</dd>
</dl>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><p><strong>type</strong> – <em>str, (optional)</em>: Filter by coverage type using coverage code. Defaults to None.</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
<p>Note: The <ac:link ac:anchor="Coverage(Deprecated)">
<ri:page ri:content-title="Coverage (Deprecated)" />
<ac:link-body><code>Coverage</code></ac:link-body>
</ac:link> class is automatically imported when this by group is called.</p>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byCoverageType</ac:parameter>
</ac:structured-macro>
<strong><code>byCoverageType</code></strong>(<em><em>type</em>=None</em>)</dt>
<dd><dl>
<dt>Filter your query by coverage type. Most top level objects inherit this function such as Enrollment, Trend, etc.</dt>
<dd>
<p>If your object is already set by a by group this will add it as the next by group.</p>
</dd>
</dl>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><p><strong>type</strong> – <em>str, (optional)</em>: Filter by coverage type using coverage code. Defaults to None.</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
<p>Note: The <ac:link ac:anchor="Coverage(Deprecated)">
<ri:page ri:content-title="Coverage (Deprecated)" />
<ac:link-body><code>Coverage</code></ac:link-body>
</ac:link> class is automatically imported when this by group is called.</p>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byEnrollmentType</ac:parameter>
</ac:structured-macro>
<strong><code>byEnrollmentType</code></strong>(<em><em>type</em>=None</em>)</dt>
<dd><dl>
<dt>Filter your query by enrollment type. Most top level objects inherit this function such as Eligibility, Trend, etc.</dt>
<dd>
<p>If your object is already set by a by group this will add it as the next by group.</p>
</dd>
</dl>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><p><strong>type</strong> – <em>str, (optional)</em>: Filter by coverage type using enrollment type code. Defaults to None.</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byMedicaidOnly</ac:parameter>
</ac:structured-macro>
<strong><code>byMedicaidOnly</code></strong>(<em><em>state_fips</em>=None</em>)</dt>
<dd><p>Filter your query to only include counts and percentage changes for Medicaid. Most top level objects inherit this function such as Enrollment, Trend, etc. If your object is already set by a by group this will add it as the next by group.</p>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><p><strong>state_fips</strong> – <em>str, (optional)</em>: Filter by State using FIPS code. See also <code>State.__init__()</code>. Defaults to None.</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byIncomeBracket</ac:parameter>
</ac:structured-macro>
<strong><code>byIncomeBracket</code></strong>(<em><em>bracket</em>=None</em>)</dt>
<dd><dl>
<dt>Filter your query by income bracket. Most top level objects inherit this function such as Enrollment, Trend, etc.</dt>
<dd>
<p>If your object is already set by a by group this will add it as the next by group.</p>
</dd>
</dl>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><p><strong>bracket</strong> (<em>str, (optional)</em>: Filter by income. Defaults to None.) – </p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><strong>Spark DataFrame</strong></p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
</tbody>
</table>
<p style="font-weight: bold; margin-top: 30px">Examples</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> Enrollment.byIncomeBracket('01')
or
>>> Trend.byIncomeBracket('01-03')
or
>>> Trend.byIncomeBracket('02,03,05')]]></ac:plain-text-body>
</ac:structured-macro>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byYear</ac:parameter>
</ac:structured-macro>
<strong><code>byYear</code></strong>(<em><em>year</em>: <em>Optional[int]</em> = None</em>, <em><em>count</em>: <em>int</em> = 1</em>)</dt>
<dd><p>Filter your query by Year. Most top level objects inherit this function such as Enrollment, Trend, etc.</p>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><ul>
<li>
<p><strong>year</strong> – <em>int, (optional)</em>: Filter by year using the year in numerical format. Defaults to None.</p>
</li>
<li>
<p><strong>count</strong> – <em>int, (optional)</em>: Specify the number of years before or after the year specified. Defaults to 1.</p>
</li>
</ul>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.byMonth</ac:parameter>
</ac:structured-macro>
<strong><code>byMonth</code></strong>(<em><em>month</em>: <em>Optional[int]</em> = None</em>)</dt>
<dd><p>Filter your query by Month. Most top level objects inherit this function such as Enrollment, Trend, etc.</p>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><p><strong>month</strong> – <em>int, (optional)</em>: Filter by month using the month in numerical format. Defaults to None.</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p><ac:link ac:anchor="Paletable">
<ac:link-body><code>Paletable</code></ac:link-body>
</ac:link>: returns the updated object</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark DataFrame</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.sql</ac:parameter>
</ac:structured-macro>
<strong><code>sql</code></strong>()</dt>
<dd><p>The SQL query that the Enrollment class uses to pull dataframes.</p>
<p>This can be called allowing an analyst to view the SQL the Enrollment is using.</p>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><p><strong>None</strong> – No input required.</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p>Returns a text string containing the SQL query run by the Enrollment class.</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>str</p>
</td>
</tr>
</tbody>
</table>
<p style="font-weight: bold; margin-top: 30px">Example</p>
<p>Create object containing the SQL query:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> q = Enrollment().byState().sql()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return the query as text:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> print(q)]]></ac:plain-text-body>
</ac:structured-macro>
<p>Alternatively</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> print(Enrollment().byState().sql())]]></ac:plain-text-body>
</ac:structured-macro>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.fetch</ac:parameter>
</ac:structured-macro>
<strong><code>fetch</code></strong>()</dt>
<dd><p>Call this method at the end of an object when you are ready for results.</p>
<p>This can be leveraged with display() to quickly pivot results.</p>
<table>
<tbody>
<tr>
<td style="border: none"><strong>Parameters:</strong></td>
<td style="border: none"><p><strong>None</strong> – No input required</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Returns:</strong></td>
<td style="border: none"><p>Executes your query and returns a Spark Datarame.</p>
</td>
</tr>
<tr>
<td style="border: none"><strong>Return type:</strong></td>
<td style="border: none"><p>Spark Datarame</p>
</td>
</tr>
</tbody>
</table>
<p style="font-weight: bold; margin-top: 30px">Example</p>
<p>Create object for enrollment by state and year</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api = Enrollment().byState()]]></ac:plain-text-body>
</ac:structured-macro>
<p>Return Spark DataFrame:</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> api.fetch]]></ac:plain-text-body>
</ac:structured-macro>
<p>Lever display() to pivot from yearly to monthly</p>
<ac:structured-macro ac:name="code">
<ac:parameter ac:name="language">python</ac:parameter>
<ac:plain-text-body><![CDATA[>>> display(api.byMonth().fetch())]]></ac:plain-text-body>
</ac:structured-macro>
</dd>
</dl>
<dl>
<dt><ac:structured-macro ac:name="anchor">
<ac:parameter ac:name="">Paletable.Paletable.log</ac:parameter>
</ac:structured-macro>
<strong><code>log</code></strong>(<em><em>viewname</em>: <em>str</em></em>, <em><em>sql</em>=&apos;&apos;</em>)</dt>
<dd><p>This attribute allows you to print out the sql of a specific view within databricks or a database</p>
</dd>
</dl>
</dd>
</dl>
